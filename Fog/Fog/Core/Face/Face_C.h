// [Fog-Core]
//
// [License]
// MIT, See COPYING file in package

// [Guard]
#ifndef _FOG_CORE_FACE_FACE_C_H
#define _FOG_CORE_FACE_FACE_C_H

// [Dependencies]
#include <Fog/Core/Face/Face_Constants.h>

#include <Fog/Core/Face/Face_C_P32.h>
#include <Fog/Core/Face/Face_C_P64.h>
#include <Fog/Core/Face/Face_C_F32.h>

#if defined(FOG_DOXYGEN)

// ============================================================================
// [Fog::Face]
// ============================================================================

//! @defgroup Fog_Face Fog::Face (Fog Accelerated C Extensions)
//!
//! Public classes and functions related to Fog::Face framework. Fog::Face was 
//! created to simplify the development of low-level multimedia functions used 
//! for digital signal processing (computer graphics, audio, ...).

// ============================================================================
// [Fog::Face - Features]
// ============================================================================

//! @defgroup Fog_Face_Features Fog::Face features setup.
//! @ingroup Fog_Face
//!
//! This section contains various C++ macros that can be used to tweak the
//! binary code generated by the C++ compiler. The aim of these macros is to 
//! group processor dependent features into few macros used by the Fog::Face
//! framework. For example X86/AMD64 platform has very fast addition and multiply
//! so it's prefered over more logical instructions.

// ============================================================================
// [Fog::Face - C]
// ============================================================================

//! @defgroup Fog_Face_C Packed 32-bit and 64-bit datatype manipulation in C.
//! @ingroup Fog_Face
//! 
//! Collection of typedefs and functions to work with scalar bytes or bytes 
//! packed in 32-bit or 64-bit unsigned integers.
//!
//! Functions defined by @ref Fog_Face_C do operation on:
//!
//!   1. scalar byte:
//!      - suffix "SBB"
//!   2. packed bytes (0xB3B2B1B0):
//!      - suffix "PBB"
//!   3. scalar byte as word:
//!      - suffix "SBW"
//!   4. packed bytes as words (0x__B0__B0, etc...):
//!      - suffix "PBW"
//!
//! Data format for working with pixels in 32-bit mode:
//!
//!   - PBB b3210 [0xAARRGGBB]
//!
//!   - PBW b_2_0 [0x00RR00BB]
//!   - PBW b_3_1 [0x00AA00GG]
//!
//! Data format for working with pixels in 64-bit mode:
//!
//!   - PBB b3210 [0xAARRGGBB]
//!
//!   - PBW b_3_2_1_0 [0x00AA00GG00RR00BB]
//!
//! The reason to not unpack bytes to 0x00AA00RR/00GG00BB is that it's more
//! expensive, unpacking even and odd bytes separately is simpler and working
//! with the data is the same. Notice that the position of bytes/pixels is
//! different to position when using MMX/SSE2 where unpacking to AARRGGBB is
//! done using single instruction.

#endif // FOG_DOXYGEN

// [Guard]
#endif // _FOG_CORE_FACE_FACE_C_H
